class(model) ::=<<
<packageAndImports(model)>
<headerAndFields(model)>

  <portDeclarations(model)>
  <constructor(model)>
  <initAndGetters(model)>
  <subAndPubChannelAssignments(model)>
  <abstractMethods(model)>
  <tasks(model)>
}
>>

tasks(model) ::=<<
<model.tasks.keys:{k |<task(k, model.tasks.(k))>}>
>>

task(taskName, taskModel) ::=<<


public class <taskName>Task implements Task {
<[taskModel.incomingGlobals, taskModel.outgoingGlobals]:{vm | <globalDeclaration(vm.innerName, vm.type)>
}>
  @Override
  public void run() {
    <taskModel.incomingGlobals:{vm | <initGlobal(vm.innerName, vm.outerName)>
    }>
    MdcfMessage message = <taskModel.trigPortName>ReceiverPort.getReceiver().getLastMsg();
    try {
      <taskModel.trigPortType> <taskModel.trigPortLocalName>Data = <taskModel.trigPortName>ReceiverPort.getLastMsgContent();
      <exchName>ListenerOnMessage(message, <exchName>Data);
    } catch (MdcfDecodeMessageException e) {
      System.err.println(getComponentTypeName() + ".<taskName>Task task: invalid message:" + message.getTextMsg());
      e.printStackTrace();
    }
    <taskModel.outgoingGlobals:{vm | <updateGlobal(vm.innerName, vm.outerName)>
    }>
  }
}
>>

initGlobal(innerName, outerName) ::=<<
<innerName> = get<outerName>();
>>

updateGlobal(innerName, outerName) ::=<<
set<outerName>(<innerName>);
>>

abstractMethods(model) ::=<<


protected abstract void initComponent();
  
<model.receivePorts.keys:{k |<abstractListener(k, model.receivePorts.(k))>
}>
>>

abstractListener(exchName, exchType) ::=<<
protected abstract void <exchName>ListenerOnMessage(MdcfMessage msg, <exchType> <exchName>Data);
>>

subAndPubChannelAssignments(model) ::=<<
@Override
public void processSubscriberChannelAssignment(SubChannelAssignmentMsg subAssign) {
  <model.receivePorts.keys:{k |<subChannelAssignment(k)>
  }>}

@Override
public void processPublisherChannelAssignment(PubChannelAssignmentMsg pubAssign) {
  <model.sendPorts.keys:{k |<pubChannelAssignment(k)>
  }>}
>>

pubChannelAssignment(exchName) ::=<<
publisherChannelAssignmentHelper(pubAssign, this.<exchName>SenderPort);
>>

subChannelAssignment(exchName) ::=<<
subscriberChannelAssignmentHelper(subAssign, this.<exchName>ReceiverPort);
>>

initAndGetters(model) ::=<<


@Override
public void init(){
  initComponent();
}

@Override
protected Map\<String, Task> getTaskInstanceMap() {
  return this.taskInstanceMap;
}

@Override
protected Map\<String, MdcfReceiverPort\<?>\> getReceiverPortMap(){
  return this.receiverPortMap;
}

<model.globals.keys:{k |<globalGetter(k, model.globals.(k))>
}><model.globals.keys:{k |<globalSetter(k, model.globals.(k))>
}>
>>

globalGetter(name, type) ::=<<
private <type> get<name>(){
  return <name>;
}

>>

globalSetter(name, type) ::=<<
private void set<name>(<type> val){
  <name> = val;
}

>>

constructor(model) ::=<<
public <model.objectName>SuperType(String GUID) {
  super(GUID, "<model.objectName>");
  taskInstanceMap = new HashMap\<>();
  receiverPortMap = new HashMap\<>();
  <model.tasks.keys:{k |<taskInstanceMapEntry(k)>
  }><model.receivePorts.keys:{k |<receiverPortMapEntry(k)>
  }>}
>>

receiverPortMapEntry(exchName) ::=<<
  receiverPortMap.put(<exchName>ReceiverPort.getName(), <exchName>ReceiverPort);
>>

taskInstanceMapEntry(exchName) ::=<<
taskInstanceMap.put(<exchName>ReceiverTask.class.getSimpleName(), new <exchName>ReceiverTask());
>>

portDeclarations(model) ::=<<
<model.receivePorts.keys:{k |<receiverDeclaration(k, model.receivePorts.(k))>}>
<model.sendPorts.keys:{k |<senderDeclaration(k, model.sendPorts.(k))>}>
>>

senderDeclaration(exchName, exchType) ::=<<
private MdcfSenderPort\<<exchType>\> <exchName>SenderPort = new MdcfSenderPort\<>("<exchName>Out", <exchType>.class);

>>

receiverDeclaration(exchName, exchType) ::=<<
private MdcfReceiverPort\<<exchType>\> <exchName>ReceiverPort = new MdcfReceiverPort\<>("<exchName>In", <exchType>.class);

>>

headerAndFields(model) ::=<<
<if(model.isDisplay)>
public class <model.objectName>SuperType extends AppPanelComponent{
<else>
public class <model.objectName>PseudoDevice extends LogicComponent{
<endif>
  private HashMap\<String, Task> taskInstanceMap;
  private HashMap\<String, MdcfReceiverPort\<?>\> receiverPortMap;
<model.globals.keys:{k |<globalDeclaration(k, model.globals.(k))>
}> >>

globalDeclaration(name, type) ::=<<
  private <type> <name>;
>>

packageAndImports(model) ::=<<
package mdcf.app.<model.objectName>;

import java.util.HashMap;
import java.util.Map;

import mdcf.channelservice.common.MdcfDecodeMessageException;
import mdcf.channelservice.common.MdcfReceiverPort;
import mdcf.channelservice.common.MdcfSenderPort;
import mdcf.core.ctypes.Task;
<if(model.isDisplay)>
import mdcf.core.ctypes.apppanel.AppPanelComponent;
<else>
import mdcf.core.ctypes.logic.LogicComponent;
<endif>
import mdcf.core.messagetypes.devicemgmt.PubChannelAssignmentMsg;
import mdcf.core.messagetypes.devicemgmt.SubChannelAssignmentMsg;
>>



userimpl(model) ::=<<
package mdcf.app.<model.objectName>;

import mdcf.channelservice.common.MdcfMessage;
<importMessageTypes(model)>public class <model.objectName> extends <model.objectName>SuperType {

  public <model.objectName>(String GUID) {
    super(GUID);
  }

  @Override
  protected void initComponent() {
    // TODO Fill in custom initialization code here
  }
  <model.tasks.keys:{k |<userImplOnMessageStub(k, model.tasks.(k))>
  }>}
>>

userImplOnMessageStub(exchName, exchType) ::=<<


@Override
protected void <exchName>ListenerOnMessage(MdcfMessage msg, <exchType> <exchName>Data) {
  // TODO Fill in custom listener code here
}
>>